En el executor lo que se hace es primero abrir los archivos que se utilicen(puede ser un heredoc)
en la línea de ejecución y crear todos los pipes necesarios, redirigir la
información a donde venga indicado, gestionar las señales y guardar
el último código de salida (La minishell devuelve el último código de salida con "$?").

Cuando un comando sea un built-in no hay que crear un proceso hijo
y lo último es gestionar heredocs y señales


Como vamos a gestionar el tema de los paréntesis?

Si están separados por || se ejecutan las líneas de instrucciones mientras las anteriores fallen.
Si están separados por && se ejecutan mientras se ejecuten correctamente.
La profundidad de el árbol binario depende de cuantas instrucciones haya anidadas con paréntesis.

Gestionar retokenización y expander en el executor


Diferenciar built-ins y comandos que se ejecutan con execve (binarios)
(si no hay pipe)

sin pipe y built in no hace falta crear hijo, else si

si hay pipe hay que crear hijos también con el builtin

Redirecciones: hay que ejecutarlas en los hijos en principio (buscarlo)

gestionar códigos de salida, 126, 127, 1, 0 (variable global) y $?

estructura global que contenga todo

En los hijos si falla algo liberar memoria de los hijos y de los padres valgrind --trace-children=yes

Gestionar si no hay permisos, etc.