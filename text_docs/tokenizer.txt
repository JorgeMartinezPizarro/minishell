El tokenizer se encarga de procesar la entrada y dividirla en distintos tokens que recibirá el parser como input

Cosas que tiene que gestionar el lexer:

1 Convierte la línea en tokens y separa cada elemento por su tipo
2 este tokenizer tiene que respetar las comillas para expandir o no expandir variables
3 Detectar errores léxicos como comillas sin cerrar

Para el lexer hay que tener en cuenta primero si estamos tomando un archivo como entrada
y si hay algún problema al abrir ese archivo antes de hacer nada más
cat < infile | cat -e > outfile

Casos posibles:

Comillas: lo que haya dentro de unas comillas se interpreta como el string que hay
dentro de ellas

No comillas: se separa todo con un espacio

Ejemplos: (echo  hello   there ) y (echo " hello   there ")
Resultados: 
1 ("hello there") separados solo por un espacio y trimeado por izquierda y derecha
2 (" hello   there ")

todo lo que haya entre comillas dobles hay que tratarlo como un string y expandiendo
lo que haya entre comillas simples igual pero sin expandir
Ejemplos: echo 'hola  $USER' -> "hola  $USER' y echo "hola  $USER" -> "hola  maanguit"

lo importante son las comillas más exteriores para expandir o no expandir
echo "hola '$USER'" -> "hola maanguit"
echo 'hola "$USER"' -> "hola $USER"

en caso de que el comando esté dentro de un string no se ejecuta nada con "" o ''
"echo hello" -> command not found

Si hay más de un argumento siempre detecta 0 espacios si no los hay y 1 espacio
si hay n espacios:
echo hola "caracola"-> "hola caracola"
echo hola"caracola"-> "holacaracola"
echo hola  "caracola"-> "hola caracola"

También si "hola '' "->"hola "
		   'hola '' '->"hola '' "

QUÉ HACER DURANTE LA TOKENIZACIÓN?:

0 Controlar que haya algo antes y después del pipe o redirección y si hay comillas
  , además comprobar que cada paréntesis que se abre también se cierre
  y que dentro de cada paréntesis o hasta && o || las instrucciones sean correctas(bonus)
  (mirar si cuando no se cierren comillas hay que abrir un heredoc)
  (si "<<" entonces no abrir heredoc hasta que se compruebe la validez de la línea)

1 Separar los pipes, redirecciones operadores && y || tener en cuenta los paréntesis
  para la prioridad de ejecución.

2 Expandir variables si no están entre comillas simples

####### TESTER #######

if (strcmp(argv[1], "-c", 3)) (modo comando)
	cmd = argv[2] modo interactivo para automatizar los tests
else (modo interactivo)
	cmd = readline("prompt >>");


diff <(bash -c ls) <(./minishell -c ls)